/* sorting.pro: Программа на ПРОЛОГЕ для сортировки массива целых чисел по убыванию
   Для сортировки используется метод нахождения наибольшего элемента. */
domains
  list = integer*
  
predicates
  find_maxelem(list, integer) /* (i, o) */
  	/* запускающий предикат для нахождения наибольшего элемента в списке, вызывает find_maxelem_re. */
  
  find_maxelem_re(list, integer, integer) /* (i, i, o) */
  	/* рекурсивный предикат для нахождения наибольшего элемента в списке.
  	 * Второй терм - наибольший элемент, из всех рассмотренных к данному моменту */
  
  append(list, list, list) /* (i, i, o) */
  	/* Предикат для объединения двух списков в один */	
  
  cut_elem(list, integer, list)	/* (i, i, o) */
  	/* запускающий предикат для исключения элемента из списка, вызывает cut_elem_re */
  
  cut_elem_re(list, list, integer, list) /* (i, i, i, o) */
  	/* рекурсивный предикат для исключения элемента из списка */
  
  sort_list_desc(list, list) /* (i, o) */
  	/* рекурсивный предикат для выполнения сортировки списка */
  
clauses
  /* Аксиомы для нахождения наибольшего элемента списка */
  find_maxelem([H | Tail], Max) :- find_maxelem_re(Tail, H, Max).
  find_maxelem_re([], Max, Max).
  find_maxelem_re([H | Tail], CurMax, Max) :- H > CurMax, find_maxelem_re(Tail, H, Max), !.
  find_maxelem_re([_ | Tail], CurMax, Max) :- find_maxelem_re(Tail, CurMax, Max).
  	/* Если головной элемент H списка оказывается больше текущего максимального значения CurMax, процедура
  	 * запускается рекурсивно для хвостовой части списка со значением CurMax = H. Иначе процедура запускается
  	 * рекурсивно с сохранением значения CurMax. Рекурсия заканчивается, когда мы приходим к пустому списку.
  	 * При этом в текущее значение CurMax принимают за искомое максимальное значение: Max = CurMax.
  	 */
  
  /* Аксиомы для объединения двух списков в один */
  append([], List2, List2).
  append([H1 | Tail1], List2, [H1 | Tail3]) :- append(Tail1, List2, Tail3).
  
  /* Аксиомы для исключения элемента из списка */
  cut_elem(List, X, NewList) :- cut_elem_re([], List, X, NewList).
  cut_elem_re(Head, [], _, Head).	/* на случай, если элемент Х отсутствует в списке. При сортировке невозможно. */
  cut_elem_re(Head, [M | Tail], X, NewList) :- M = X, append(Head, Tail, NewList), !.
  cut_elem_re(Head, [M | Tail], X, NewList) :- append(Head, [M], NewHead), cut_elem_re(NewHead, Tail, X, NewList).
  	/*  Процедура исключения заданного элемента из списка.
  	 *  Процедура удаляет первое вхождение элемента X в список List и сохраняет полученный список в NewList.
  	 *  Процедура работает следующим образом.
  	 *  Список делим на три части: 
  	 * 
  	 *  |--------------------------|---|------------------------------|
  	 *  |           Head           | M |           Tail               |
  	 *  |--------------------------|---|------------------------------|
  	 *
  	 *  Head - головная часть, M - текущий элемент, Tail - хвостовая часть.
  	 *
  	 *  Если M <> X, то мы присоединяем текущий элемент M к головной части списка Head и переходим к анализу следующего элемента.
  	 *
  	 *  k-ый шаг рекурсии:
  	 *
  	 *  |--------------------------|---|------------------------------|
  	 *  |           Head           | M |           Tail               |
  	 *  |--------------------------|---|------------------------------|
  	 *
  	 *  (k+1)-ый шаг рекурсии:
  	 *
  	 *  |------------------------------|---|--------------------------|
  	 *  |           Head               | M |           Tail           |
  	 *  |------------------------------|---|--------------------------|
  	 *  	
  	 *  Если же M = X (заданному элементу), то мы возвращаем результирующий список, составленный из Head и Tail.
  	 *
  	 *  На Последнем шаге рекурсии в качестве результата возвращается следующий список:
  	 *
  	 *  |--------------------------|------------------------------|
  	 *  |           Head           |           Tail               |
  	 *  |--------------------------|------------------------------|
  	 *
  	 */
  	 
  /* Аксиомы для выполнения сортировки списка по убыванию */
  sort_list_desc([], []).
  sort_list_desc(List, Result) :- 
  	find_maxelem(List, Max),      	/* находим наибольший элемент списка */
  	cut_elem(List, Max, Rest),    	/* исключаем его из списка */
  	sort_list_desc(Rest, Result0), 	/* запускаем сортировку рекурсивно на полученном списке */
  	Result = [Max | Result0].	/* ставим наибольшитй элемент на первое место */
  
goal
  /*find_maxelem([3, 1, 10, 2], X).*/
  /*cut_elem([1, 2, 3, 4, 5, 6], 1, NewList).  */
  sort_list_desc([1,4,5,2], Result).
  /*sort_list_asc([10, 10, 12, 10], Result).*/
  